// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: config_revisions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRevisions = `-- name: CountRevisions :one
SELECT COUNT(*) FROM config_revisions
WHERE project_id = $1 AND config_key = $2
`

func (q *Queries) CountRevisions(ctx context.Context, projectID string, configKey string) (int64, error) {
	row := q.db.QueryRow(ctx, countRevisions, projectID, configKey)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRevisionsByProject = `-- name: CountRevisionsByProject :one
SELECT COUNT(*) FROM config_revisions
WHERE project_id = $1
`

func (q *Queries) CountRevisionsByProject(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countRevisionsByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConfigRevision = `-- name: CreateConfigRevision :one
INSERT INTO config_revisions (
    id,
    project_id,
    config_key,
    version,
    content,
    created_by_user_id
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, project_id, config_key, version, content, created_by_user_id, created_at
`

type CreateConfigRevisionParams struct {
	ID              string `db:"id" json:"id"`
	ProjectID       string `db:"project_id" json:"project_id"`
	ConfigKey       string `db:"config_key" json:"config_key"`
	Version         int64  `db:"version" json:"version"`
	Content         []byte `db:"content" json:"content"`
	CreatedByUserID string `db:"created_by_user_id" json:"created_by_user_id"`
}

func (q *Queries) CreateConfigRevision(ctx context.Context, arg CreateConfigRevisionParams) (ConfigRevision, error) {
	row := q.db.QueryRow(ctx, createConfigRevision,
		arg.ID,
		arg.ProjectID,
		arg.ConfigKey,
		arg.Version,
		arg.Content,
		arg.CreatedByUserID,
	)
	var i ConfigRevision
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConfigKey,
		&i.Version,
		&i.Content,
		&i.CreatedByUserID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldRevisions = `-- name: DeleteOldRevisions :exec
DELETE FROM config_revisions
WHERE project_id = $1 AND config_key = $2
  AND version < $3
`

func (q *Queries) DeleteOldRevisions(ctx context.Context, projectID string, configKey string, version int64) error {
	_, err := q.db.Exec(ctx, deleteOldRevisions, projectID, configKey, version)
	return err
}

const getConfigRevision = `-- name: GetConfigRevision :one
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetConfigRevision(ctx context.Context, id string) (ConfigRevision, error) {
	row := q.db.QueryRow(ctx, getConfigRevision, id)
	var i ConfigRevision
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConfigKey,
		&i.Version,
		&i.Content,
		&i.CreatedByUserID,
		&i.CreatedAt,
	)
	return i, err
}

const getConfigRevisionByVersion = `-- name: GetConfigRevisionByVersion :one
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2 AND version = $3
LIMIT 1
`

func (q *Queries) GetConfigRevisionByVersion(ctx context.Context, projectID string, configKey string, version int64) (ConfigRevision, error) {
	row := q.db.QueryRow(ctx, getConfigRevisionByVersion, projectID, configKey, version)
	var i ConfigRevision
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConfigKey,
		&i.Version,
		&i.Content,
		&i.CreatedByUserID,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestNRevisions = `-- name: GetLatestNRevisions :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2
ORDER BY version DESC
LIMIT $3
`

func (q *Queries) GetLatestNRevisions(ctx context.Context, projectID string, configKey string, limit int32) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, getLatestNRevisions, projectID, configKey, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestRevision = `-- name: GetLatestRevision :one
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetLatestRevision(ctx context.Context, projectID string, configKey string) (ConfigRevision, error) {
	row := q.db.QueryRow(ctx, getLatestRevision, projectID, configKey)
	var i ConfigRevision
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ConfigKey,
		&i.Version,
		&i.Content,
		&i.CreatedByUserID,
		&i.CreatedAt,
	)
	return i, err
}

const getRevisionHistory = `-- name: GetRevisionHistory :many
SELECT 
    cr.id, cr.project_id, cr.config_key, cr.version, cr.content, cr.created_by_user_id, cr.created_at,
    u.email as created_by_email
FROM config_revisions cr
JOIN users u ON cr.created_by_user_id = u.id
WHERE cr.project_id = $1 AND cr.config_key = $2
ORDER BY cr.version DESC
LIMIT $3
`

type GetRevisionHistoryRow struct {
	ID              string           `db:"id" json:"id"`
	ProjectID       string           `db:"project_id" json:"project_id"`
	ConfigKey       string           `db:"config_key" json:"config_key"`
	Version         int64            `db:"version" json:"version"`
	Content         []byte           `db:"content" json:"content"`
	CreatedByUserID string           `db:"created_by_user_id" json:"created_by_user_id"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	CreatedByEmail  string           `db:"created_by_email" json:"created_by_email"`
}

func (q *Queries) GetRevisionHistory(ctx context.Context, projectID string, configKey string, limit int32) ([]GetRevisionHistoryRow, error) {
	rows, err := q.db.Query(ctx, getRevisionHistory, projectID, configKey, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRevisionHistoryRow{}
	for rows.Next() {
		var i GetRevisionHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevisionsCreatedAfter = `-- name: GetRevisionsCreatedAfter :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2 AND created_at > $3
ORDER BY version ASC
`

func (q *Queries) GetRevisionsCreatedAfter(ctx context.Context, projectID string, configKey string, createdAt pgtype.Timestamp) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, getRevisionsCreatedAfter, projectID, configKey, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevisionsInVersionRange = `-- name: GetRevisionsInVersionRange :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2
  AND version >= $3 AND version <= $4
ORDER BY version ASC
`

type GetRevisionsInVersionRangeParams struct {
	ProjectID string `db:"project_id" json:"project_id"`
	ConfigKey string `db:"config_key" json:"config_key"`
	Version   int64  `db:"version" json:"version"`
	Version_2 int64  `db:"version_2" json:"version_2"`
}

func (q *Queries) GetRevisionsInVersionRange(ctx context.Context, arg GetRevisionsInVersionRangeParams) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, getRevisionsInVersionRange,
		arg.ProjectID,
		arg.ConfigKey,
		arg.Version,
		arg.Version_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllRevisionsByProject = `-- name: ListAllRevisionsByProject :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAllRevisionsByProject(ctx context.Context, projectID string) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, listAllRevisionsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigRevisions = `-- name: ListConfigRevisions :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2
ORDER BY version DESC
`

func (q *Queries) ListConfigRevisions(ctx context.Context, projectID string, configKey string) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, listConfigRevisions, projectID, configKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigRevisionsPaginated = `-- name: ListConfigRevisionsPaginated :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE project_id = $1 AND config_key = $2
ORDER BY version DESC
LIMIT $3 OFFSET $4
`

type ListConfigRevisionsPaginatedParams struct {
	ProjectID string `db:"project_id" json:"project_id"`
	ConfigKey string `db:"config_key" json:"config_key"`
	Limit     int32  `db:"limit" json:"limit"`
	Offset    int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListConfigRevisionsPaginated(ctx context.Context, arg ListConfigRevisionsPaginatedParams) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, listConfigRevisionsPaginated,
		arg.ProjectID,
		arg.ConfigKey,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRevisionsByUser = `-- name: ListRevisionsByUser :many
SELECT id, project_id, config_key, version, content, created_by_user_id, created_at FROM config_revisions
WHERE created_by_user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

func (q *Queries) ListRevisionsByUser(ctx context.Context, createdByUserID string, limit int32) ([]ConfigRevision, error) {
	rows, err := q.db.Query(ctx, listRevisionsByUser, createdByUserID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConfigRevision{}
	for rows.Next() {
		var i ConfigRevision
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ConfigKey,
			&i.Version,
			&i.Content,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
