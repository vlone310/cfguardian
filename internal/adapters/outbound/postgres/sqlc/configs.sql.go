// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: configs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeConfigSchema = `-- name: ChangeConfigSchema :one
UPDATE configs
SET
    schema_id = $3,
    updated_by_user_id = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE project_id = $1 AND key = $2
RETURNING project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at
`

type ChangeConfigSchemaParams struct {
	ProjectID       string `db:"project_id" json:"project_id"`
	Key             string `db:"key" json:"key"`
	SchemaID        string `db:"schema_id" json:"schema_id"`
	UpdatedByUserID string `db:"updated_by_user_id" json:"updated_by_user_id"`
}

func (q *Queries) ChangeConfigSchema(ctx context.Context, arg ChangeConfigSchemaParams) (Config, error) {
	row := q.db.QueryRow(ctx, changeConfigSchema,
		arg.ProjectID,
		arg.Key,
		arg.SchemaID,
		arg.UpdatedByUserID,
	)
	var i Config
	err := row.Scan(
		&i.ProjectID,
		&i.Key,
		&i.SchemaID,
		&i.Version,
		&i.Content,
		&i.UpdatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const configExists = `-- name: ConfigExists :one
SELECT EXISTS(
    SELECT 1 FROM configs
    WHERE project_id = $1 AND key = $2
) AS exists
`

func (q *Queries) ConfigExists(ctx context.Context, projectID string, key string) (bool, error) {
	row := q.db.QueryRow(ctx, configExists, projectID, key)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countConfigsByProject = `-- name: CountConfigsByProject :one
SELECT COUNT(*) FROM configs
WHERE project_id = $1
`

func (q *Queries) CountConfigsByProject(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countConfigsByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConfigsBySchema = `-- name: CountConfigsBySchema :one
SELECT COUNT(*) FROM configs
WHERE schema_id = $1
`

func (q *Queries) CountConfigsBySchema(ctx context.Context, schemaID string) (int64, error) {
	row := q.db.QueryRow(ctx, countConfigsBySchema, schemaID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConfig = `-- name: CreateConfig :one
INSERT INTO configs (
    project_id,
    key,
    schema_id,
    version,
    content,
    updated_by_user_id
) VALUES (
    $1, $2, $3, 1, $4, $5
)
RETURNING project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at
`

type CreateConfigParams struct {
	ProjectID       string `db:"project_id" json:"project_id"`
	Key             string `db:"key" json:"key"`
	SchemaID        string `db:"schema_id" json:"schema_id"`
	Content         []byte `db:"content" json:"content"`
	UpdatedByUserID string `db:"updated_by_user_id" json:"updated_by_user_id"`
}

func (q *Queries) CreateConfig(ctx context.Context, arg CreateConfigParams) (Config, error) {
	row := q.db.QueryRow(ctx, createConfig,
		arg.ProjectID,
		arg.Key,
		arg.SchemaID,
		arg.Content,
		arg.UpdatedByUserID,
	)
	var i Config
	err := row.Scan(
		&i.ProjectID,
		&i.Key,
		&i.SchemaID,
		&i.Version,
		&i.Content,
		&i.UpdatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteConfig = `-- name: DeleteConfig :exec
DELETE FROM configs
WHERE project_id = $1 AND key = $2
`

func (q *Queries) DeleteConfig(ctx context.Context, projectID string, key string) error {
	_, err := q.db.Exec(ctx, deleteConfig, projectID, key)
	return err
}

const getConfig = `-- name: GetConfig :one
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE project_id = $1 AND key = $2
LIMIT 1
`

func (q *Queries) GetConfig(ctx context.Context, projectID string, key string) (Config, error) {
	row := q.db.QueryRow(ctx, getConfig, projectID, key)
	var i Config
	err := row.Scan(
		&i.ProjectID,
		&i.Key,
		&i.SchemaID,
		&i.Version,
		&i.Content,
		&i.UpdatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfigVersion = `-- name: GetConfigVersion :one
SELECT version FROM configs
WHERE project_id = $1 AND key = $2
LIMIT 1
`

func (q *Queries) GetConfigVersion(ctx context.Context, projectID string, key string) (int64, error) {
	row := q.db.QueryRow(ctx, getConfigVersion, projectID, key)
	var version int64
	err := row.Scan(&version)
	return version, err
}

const getConfigWithVersion = `-- name: GetConfigWithVersion :one
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE project_id = $1 AND key = $2 AND version = $3
LIMIT 1
`

func (q *Queries) GetConfigWithVersion(ctx context.Context, projectID string, key string, version int64) (Config, error) {
	row := q.db.QueryRow(ctx, getConfigWithVersion, projectID, key, version)
	var i Config
	err := row.Scan(
		&i.ProjectID,
		&i.Key,
		&i.SchemaID,
		&i.Version,
		&i.Content,
		&i.UpdatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfigsUpdatedAfter = `-- name: GetConfigsUpdatedAfter :many
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE project_id = $1 AND updated_at > $2
ORDER BY updated_at DESC
`

func (q *Queries) GetConfigsUpdatedAfter(ctx context.Context, projectID string, updatedAt pgtype.Timestamp) ([]Config, error) {
	rows, err := q.db.Query(ctx, getConfigsUpdatedAfter, projectID, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Config{}
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.ProjectID,
			&i.Key,
			&i.SchemaID,
			&i.Version,
			&i.Content,
			&i.UpdatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigsUpdatedByUser = `-- name: GetConfigsUpdatedByUser :many
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE updated_by_user_id = $1
ORDER BY updated_at DESC
LIMIT $2
`

func (q *Queries) GetConfigsUpdatedByUser(ctx context.Context, updatedByUserID string, limit int32) ([]Config, error) {
	rows, err := q.db.Query(ctx, getConfigsUpdatedByUser, updatedByUserID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Config{}
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.ProjectID,
			&i.Key,
			&i.SchemaID,
			&i.Version,
			&i.Content,
			&i.UpdatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigsByProject = `-- name: ListConfigsByProject :many
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE project_id = $1
ORDER BY key
`

func (q *Queries) ListConfigsByProject(ctx context.Context, projectID string) ([]Config, error) {
	rows, err := q.db.Query(ctx, listConfigsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Config{}
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.ProjectID,
			&i.Key,
			&i.SchemaID,
			&i.Version,
			&i.Content,
			&i.UpdatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigsBySchema = `-- name: ListConfigsBySchema :many
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE schema_id = $1
ORDER BY project_id, key
`

func (q *Queries) ListConfigsBySchema(ctx context.Context, schemaID string) ([]Config, error) {
	rows, err := q.db.Query(ctx, listConfigsBySchema, schemaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Config{}
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.ProjectID,
			&i.Key,
			&i.SchemaID,
			&i.Version,
			&i.Content,
			&i.UpdatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockConfigForUpdate = `-- name: LockConfigForUpdate :one
SELECT version FROM configs
WHERE project_id = $1 AND key = $2
FOR UPDATE
`

// Optimistic locking helper - get current version for update
func (q *Queries) LockConfigForUpdate(ctx context.Context, projectID string, key string) (int64, error) {
	row := q.db.QueryRow(ctx, lockConfigForUpdate, projectID, key)
	var version int64
	err := row.Scan(&version)
	return version, err
}

const searchConfigsByKey = `-- name: SearchConfigsByKey :many
SELECT project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at FROM configs
WHERE project_id = $1 AND key ILIKE $2
ORDER BY key
LIMIT $3
`

func (q *Queries) SearchConfigsByKey(ctx context.Context, projectID string, key string, limit int32) ([]Config, error) {
	rows, err := q.db.Query(ctx, searchConfigsByKey, projectID, key, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Config{}
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.ProjectID,
			&i.Key,
			&i.SchemaID,
			&i.Version,
			&i.Content,
			&i.UpdatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConfig = `-- name: UpdateConfig :one
UPDATE configs
SET
    content = $4,
    version = version + 1,
    updated_by_user_id = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE project_id = $1 AND key = $2 AND version = $3
RETURNING project_id, key, schema_id, version, content, updated_by_user_id, created_at, updated_at
`

type UpdateConfigParams struct {
	ProjectID       string `db:"project_id" json:"project_id"`
	Key             string `db:"key" json:"key"`
	Version         int64  `db:"version" json:"version"`
	Content         []byte `db:"content" json:"content"`
	UpdatedByUserID string `db:"updated_by_user_id" json:"updated_by_user_id"`
}

func (q *Queries) UpdateConfig(ctx context.Context, arg UpdateConfigParams) (Config, error) {
	row := q.db.QueryRow(ctx, updateConfig,
		arg.ProjectID,
		arg.Key,
		arg.Version,
		arg.Content,
		arg.UpdatedByUserID,
	)
	var i Config
	err := row.Scan(
		&i.ProjectID,
		&i.Key,
		&i.SchemaID,
		&i.Version,
		&i.Content,
		&i.UpdatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
