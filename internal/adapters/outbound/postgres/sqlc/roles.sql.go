// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRole = `-- name: AssignRole :one
INSERT INTO roles (
    user_id,
    project_id,
    role_level
) VALUES (
    $1, $2, $3
)
ON CONFLICT (user_id, project_id)
DO UPDATE SET
    role_level = EXCLUDED.role_level,
    updated_at = CURRENT_TIMESTAMP
RETURNING user_id, project_id, role_level, created_at, updated_at
`

func (q *Queries) AssignRole(ctx context.Context, userID string, projectID string, roleLevel RoleLevel) (Role, error) {
	row := q.db.QueryRow(ctx, assignRole, userID, projectID, roleLevel)
	var i Role
	err := row.Scan(
		&i.UserID,
		&i.ProjectID,
		&i.RoleLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countRolesByProject = `-- name: CountRolesByProject :one
SELECT COUNT(*) FROM roles
WHERE project_id = $1
`

func (q *Queries) CountRolesByProject(ctx context.Context, projectID string) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRolesByUser = `-- name: CountRolesByUser :one
SELECT COUNT(*) FROM roles
WHERE user_id = $1
`

func (q *Queries) CountRolesByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRole = `-- name: GetRole :one
SELECT user_id, project_id, role_level, created_at, updated_at FROM roles
WHERE user_id = $1 AND project_id = $2
LIMIT 1
`

func (q *Queries) GetRole(ctx context.Context, userID string, projectID string) (Role, error) {
	row := q.db.QueryRow(ctx, getRole, userID, projectID)
	var i Role
	err := row.Scan(
		&i.UserID,
		&i.ProjectID,
		&i.RoleLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT role_level FROM roles
WHERE user_id = $1 AND project_id = $2
LIMIT 1
`

func (q *Queries) GetUserRole(ctx context.Context, userID string, projectID string) (RoleLevel, error) {
	row := q.db.QueryRow(ctx, getUserRole, userID, projectID)
	var role_level RoleLevel
	err := row.Scan(&role_level)
	return role_level, err
}

const listProjectRoles = `-- name: ListProjectRoles :many
SELECT r.user_id, r.project_id, r.role_level, r.created_at, r.updated_at, u.email as user_email
FROM roles r
JOIN users u ON r.user_id = u.id
WHERE r.project_id = $1
ORDER BY r.role_level, u.email
`

type ListProjectRolesRow struct {
	UserID    string           `db:"user_id" json:"user_id"`
	ProjectID string           `db:"project_id" json:"project_id"`
	RoleLevel RoleLevel        `db:"role_level" json:"role_level"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	UserEmail string           `db:"user_email" json:"user_email"`
}

func (q *Queries) ListProjectRoles(ctx context.Context, projectID string) ([]ListProjectRolesRow, error) {
	rows, err := q.db.Query(ctx, listProjectRoles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectRolesRow{}
	for rows.Next() {
		var i ListProjectRolesRow
		if err := rows.Scan(
			&i.UserID,
			&i.ProjectID,
			&i.RoleLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesByLevel = `-- name: ListRolesByLevel :many
SELECT r.user_id, r.project_id, r.role_level, r.created_at, r.updated_at, u.email as user_email, p.name as project_name
FROM roles r
JOIN users u ON r.user_id = u.id
JOIN projects p ON r.project_id = p.id
WHERE r.role_level = $1
ORDER BY p.name, u.email
`

type ListRolesByLevelRow struct {
	UserID      string           `db:"user_id" json:"user_id"`
	ProjectID   string           `db:"project_id" json:"project_id"`
	RoleLevel   RoleLevel        `db:"role_level" json:"role_level"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	UserEmail   string           `db:"user_email" json:"user_email"`
	ProjectName string           `db:"project_name" json:"project_name"`
}

func (q *Queries) ListRolesByLevel(ctx context.Context, roleLevel RoleLevel) ([]ListRolesByLevelRow, error) {
	rows, err := q.db.Query(ctx, listRolesByLevel, roleLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRolesByLevelRow{}
	for rows.Next() {
		var i ListRolesByLevelRow
		if err := rows.Scan(
			&i.UserID,
			&i.ProjectID,
			&i.RoleLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserEmail,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoles = `-- name: ListUserRoles :many
SELECT r.user_id, r.project_id, r.role_level, r.created_at, r.updated_at, p.name as project_name
FROM roles r
JOIN projects p ON r.project_id = p.id
WHERE r.user_id = $1
ORDER BY p.name
`

type ListUserRolesRow struct {
	UserID      string           `db:"user_id" json:"user_id"`
	ProjectID   string           `db:"project_id" json:"project_id"`
	RoleLevel   RoleLevel        `db:"role_level" json:"role_level"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ProjectName string           `db:"project_name" json:"project_name"`
}

func (q *Queries) ListUserRoles(ctx context.Context, userID string) ([]ListUserRolesRow, error) {
	rows, err := q.db.Query(ctx, listUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserRolesRow{}
	for rows.Next() {
		var i ListUserRolesRow
		if err := rows.Scan(
			&i.UserID,
			&i.ProjectID,
			&i.RoleLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllProjectRoles = `-- name: RevokeAllProjectRoles :exec
DELETE FROM roles
WHERE project_id = $1
`

func (q *Queries) RevokeAllProjectRoles(ctx context.Context, projectID string) error {
	_, err := q.db.Exec(ctx, revokeAllProjectRoles, projectID)
	return err
}

const revokeAllUserRoles = `-- name: RevokeAllUserRoles :exec
DELETE FROM roles
WHERE user_id = $1
`

func (q *Queries) RevokeAllUserRoles(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, revokeAllUserRoles, userID)
	return err
}

const revokeRole = `-- name: RevokeRole :exec
DELETE FROM roles
WHERE user_id = $1 AND project_id = $2
`

func (q *Queries) RevokeRole(ctx context.Context, userID string, projectID string) error {
	_, err := q.db.Exec(ctx, revokeRole, userID, projectID)
	return err
}

const roleExists = `-- name: RoleExists :one
SELECT EXISTS(
    SELECT 1 FROM roles
    WHERE user_id = $1 AND project_id = $2
) AS exists
`

func (q *Queries) RoleExists(ctx context.Context, userID string, projectID string) (bool, error) {
	row := q.db.QueryRow(ctx, roleExists, userID, projectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    role_level = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND project_id = $2
RETURNING user_id, project_id, role_level, created_at, updated_at
`

func (q *Queries) UpdateRole(ctx context.Context, userID string, projectID string, roleLevel RoleLevel) (Role, error) {
	row := q.db.QueryRow(ctx, updateRole, userID, projectID, roleLevel)
	var i Role
	err := row.Scan(
		&i.UserID,
		&i.ProjectID,
		&i.RoleLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const userHasMinimumRole = `-- name: UserHasMinimumRole :one
SELECT EXISTS(
    SELECT 1 FROM roles
    WHERE user_id = $1 AND project_id = $2
    AND (
        ($3 = 'viewer' AND role_level IN ('viewer', 'editor', 'admin')) OR
        ($3 = 'editor' AND role_level IN ('editor', 'admin')) OR
        ($3 = 'admin' AND role_level = 'admin')
    )
) AS exists
`

func (q *Queries) UserHasMinimumRole(ctx context.Context, userID string, projectID string, column3 interface{}) (bool, error) {
	row := q.db.QueryRow(ctx, userHasMinimumRole, userID, projectID, column3)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userHasRole = `-- name: UserHasRole :one
SELECT EXISTS(
    SELECT 1 FROM roles
    WHERE user_id = $1 AND project_id = $2 AND role_level = $3
) AS exists
`

func (q *Queries) UserHasRole(ctx context.Context, userID string, projectID string, roleLevel RoleLevel) (bool, error) {
	row := q.db.QueryRow(ctx, userHasRole, userID, projectID, roleLevel)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
